#!/usr/bin/env python
# encoding: utf-8

from meld import vault
import argparse
import numpy


def parse_args():
    parser = argparse.ArgumentParser(
        description='Extract frames from a trajectory.')
    subparsers = parser.add_subparsers(dest='command')

    # extract trajectory
    extract = subparsers.add_parser('extract_traj', help='extract a trajectory for one replica')
    extract.add_argument('output_filename', help='filename of the output pdb file')
    extract.add_argument('--start', type=int, default=None,
                         help='first frame to extract (default: first')
    extract.add_argument('--end', type=int, default=None,
                         help='last frame to extract (default: last)')
    extract.add_argument('--replica', type=int, default=0,
                         help='replica to extract (default: 0)')
    extract.set_defaults(func=extract_traj)

    # extract last
    last = subparsers.add_parser('extract_last', help='extract the last frame for each replica from a trajectory')
    last.add_argument('name', help='template filename of the output pdb file')
    last.add_argument('--end', type=int, default=None,
                      help='frame to extract (default: last)')
    last.set_defaults(func=extract_last)

    # exctract random
    random = subparsers.add_parser('extract_random', help='extract random frames from a trajectory for reseeding')
    random.add_argument('name', help='template filename of the output pdb file')
    random.add_argument('--start', type=int, default=None,
                        help='first frame to extract (default: first')
    random.add_argument('--end', type=int, default=None,
                        help='last frame to extract (default: last)')
    random.add_argument('--replica', type=int, default=0,
                        help='replica to extract (default: 0)')
    random.add_argument('--n_frames', type=int, default=None,
                        help='number of frames to extract (default: number of replicas)')
    random.set_defaults(func=extract_random)

    return parser.parse_args()


def main():
    args = parse_args()

    store = vault.DataStore.load_data_store()
    store.initialize(mode='r')

    args.func(store, args)


def extract_traj(store, args):
    pdb_writer = get_pdb_writer(store)

    #extract gets killed by loading all
    positions = numpy.concatenate([numpy.array(store.load_positions(i))[..., numpy.newaxis]
                                       for i in range(9000,10000)], axis=-1)
    n_replicas = positions.shape[0]
    positions = positions[args.replica, ...]

    #positions = load_all_frames(store)
    #max_step = positions.shape[3]
    #n_replicas = positions.shape[0]
    max_step = 1000

    start = args.start
    if not start is None:
        assert start > 0
        assert start < max_step
    else:
        start = 1

    end = args.end
    if not end is None:
        assert end > 0
        assert end < max_step
        assert end > start
    else:
        end = max_step - 1

    replica_index = args.replica
    assert replica_index >= 0
    assert replica_index < n_replicas

    with open(args.output_filename, 'w') as output_file:
        for step in range(start, end + 1):
            pdb_string = pdb_writer.get_pdb_string(positions[replica_index, :, step], step)
            output_file.write(pdb_string)


def extract_last(store, args):
    pdb_writer = get_pdb_writer(store)

    if args.end is None:
        positions = load_all_frames(store)
        max_step = positions.shape[3]
        positions = positions[:, :, :, max_step - 1]
    else:
        positions = load_single_frame(store, args.end)
    print positions.shape
    n_replicas = positions.shape[0]

    for rep_index in range(n_replicas):
        with open('{0}_{1:03d}.pdb'.format(args.name, rep_index), 'w') as outfile:
            pdb_string = pdb_writer.get_pdb_string(positions[rep_index, :, :], args.end)
            outfile.write(pdb_string)


def extract_random(store, args):
    pdb_writer = get_pdb_writer(store)

    if args.end is None and args.start is None:
        positions = load_all_frames(store)
        n_replicas = positions.shape[0]
        positions = positions[args.replica, ...]
    elif not (args.end is None) and not (args.start is None):
        positions = numpy.concatenate([numpy.array(store.load_positions(i))[..., numpy.newaxis]
                                       for i in range(args.start, args.end)], axis=-1)
        n_replicas = positions.shape[0]
        positions = positions[args.replica, ...]
    else:
        raise ValueError('Must specify both --start and --end or neither')

    if args.n_frames is None:
        n_frames = n_replicas
    else:
        n_frames = args.n_frames

    random_frames = numpy.random.randint(0, positions.shape[2], n_frames)

    for index, frame in enumerate(random_frames):
        with open('{}_{}.pdb'.format(args.name, index), 'w') as outfile:
            pdb_string = pdb_writer.get_pdb_string(positions[:, :, frame], frame)
            outfile.write(pdb_string)


def get_pdb_writer(store):
    system = store.load_system()
    pdb_writer = system.get_pdb_writer()
    return pdb_writer


def load_all_frames(store):
    return store.load_all_positions()


def load_single_frame(store, frame):
    return store.load_positions(frame)

if __name__ == '__main__':
    main()
